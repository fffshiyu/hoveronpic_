<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hover shader on image effect</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; }
  canvas { display: block; }
</style>
</head>
<body>
<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 10);
camera.position.z = 1.5;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const texture = new THREE.TextureLoader().load(
  "https://picsum.photos/800/600",
  // 加载成功回调
  function(texture) {
    console.log("图片加载成功:", texture);
    texture.needsUpdate = true;
  },
  // 加载进度回调
  function(progress) {
    console.log("加载进度:", (progress.loaded / progress.total * 100) + '%');
  },
  // 加载错误回调
  function(error) {
    console.error("图片加载失败:", error);
    alert("图片加载失败，请检查控制台错误信息");
  }
);

// Shader 材质
const material = new THREE.ShaderMaterial({
  uniforms: {
    map: { value: texture },
    u_time: { value: 0 },
    u_mouse: { value: new THREE.Vector2(-1,-1) }, // 初始不可见
    u_rippleTime: { value: 0 }
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
  `,
  fragmentShader: `
    uniform sampler2D map;
    uniform vec2 u_mouse;
    uniform float u_rippleTime;
    uniform float u_time;
    varying vec2 vUv;

    void main() {
      vec2 uv = vUv;
      vec4 color = texture2D(map, uv);

      float dist = distance(vUv, u_mouse);
      float ripple = 0.0;

      if(u_rippleTime > 0.0) {
        float t = u_time - u_rippleTime;
        if(t < 0.8) { // 波纹持续时间
          float mask = smoothstep(0.15, 0.0, dist);
          ripple = sin(dist*50.0 - t*6.0) * 0.02 * mask * (1.0 - t/0.8);
          uv += normalize(vUv - u_mouse) * ripple;
          color = texture2D(map, uv);
        }
      }

      gl_FragColor = color;
    }
  `
});

// 平面几何体
const geometry = new THREE.PlaneGeometry(1.5,1,64,64);
const mesh = new THREE.Mesh(geometry, material);
scene.add(mesh);

// 调试信息
console.log("场景对象:", scene);
console.log("几何体:", geometry);
console.log("材质:", material);
console.log("网格:", mesh);
console.log("纹理:", texture);

// 鼠标触发一次涟漪
renderer.domElement.addEventListener('mousemove', (e) => {
  const rect = renderer.domElement.getBoundingClientRect();
  const x = (e.clientX - rect.left)/rect.width;
  const y = 1.0 - (e.clientY - rect.top)/rect.height;

  material.uniforms.u_mouse.value.set(x,y);
  material.uniforms.u_rippleTime.value = material.uniforms.u_time.value;
});

// 动画循环
const clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  material.uniforms.u_time.value = clock.getElapsedTime();
  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize', () => {
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});
</script>
</body>
</html>
